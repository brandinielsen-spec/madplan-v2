---
phase: 02-core-data-flow
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - madplan-v2/src/hooks/use-ejere.ts
  - madplan-v2/src/hooks/use-ugeplan.ts
  - madplan-v2/src/hooks/use-opskrifter.ts
  - madplan-v2/src/hooks/use-indkobsliste.ts
autonomous: true

must_haves:
  truths:
    - "SWR hooks return typed data matching interfaces"
    - "Shopping list checkbox toggle updates optimistically"
    - "Week plan mutations trigger revalidation"
  artifacts:
    - path: "madplan-v2/src/hooks/use-ejere.ts"
      provides: "SWR hook for owner list"
      exports: ["useEjere"]
    - path: "madplan-v2/src/hooks/use-ugeplan.ts"
      provides: "SWR hook for week plan with mutations"
      exports: ["useUgeplan"]
    - path: "madplan-v2/src/hooks/use-opskrifter.ts"
      provides: "SWR hook for recipes"
      exports: ["useOpskrifter"]
    - path: "madplan-v2/src/hooks/use-indkobsliste.ts"
      provides: "SWR hook for shopping list with optimistic updates"
      exports: ["useIndkobsliste"]
  key_links:
    - from: "SWR hooks"
      to: "/api/madplan/* routes"
      via: "useSWR and useSWRMutation"
      pattern: "useSWR.*api/madplan"
---

<objective>
Create SWR data hooks for all data entities with proper typing and optimistic updates.

Purpose: Encapsulate data fetching logic in reusable hooks that UI components can consume. Shopping list needs optimistic updates for responsive checkbox toggle.

Output: 4 SWR hook files with typed returns and mutation support.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-core-data-flow/02-RESEARCH.md
@.planning/phases/02-core-data-flow/02-01-SUMMARY.md

# Types and utilities from Plan 01
@madplan-v2/src/lib/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create hooks directory and simple data hooks</name>
  <files>
    madplan-v2/src/hooks/use-ejere.ts
    madplan-v2/src/hooks/use-opskrifter.ts
  </files>
  <action>
Create hooks directory if not exists: `src/hooks/`

Create `src/hooks/use-ejere.ts`:

```typescript
import useSWR from 'swr'
import type { Ejer } from '@/lib/types'

export function useEjere() {
  const { data, error, isLoading } = useSWR<Ejer[]>(
    '/api/madplan/ejere'
  )

  return {
    ejere: data ?? [],
    isLoading,
    isError: !!error,
    error,
  }
}
```

Create `src/hooks/use-opskrifter.ts`:

```typescript
import useSWR from 'swr'
import type { Opskrift } from '@/lib/types'

export function useOpskrifter(ejerId: string | null) {
  const { data, error, isLoading, mutate } = useSWR<Opskrift[]>(
    ejerId ? `/api/madplan/opskrifter?ejerId=${ejerId}` : null
  )

  return {
    opskrifter: data ?? [],
    isLoading,
    isError: !!error,
    error,
    mutate,
  }
}
```

Note: ejerId can be null - SWR will not fetch until ejerId is provided (conditional fetching).
  </action>
  <verify>
Run `npx tsc --noEmit` to verify hooks compile.
Check hooks export correct types.
  </verify>
  <done>
use-ejere.ts and use-opskrifter.ts created with proper typing.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create useUgeplan hook with mutations</name>
  <files>madplan-v2/src/hooks/use-ugeplan.ts</files>
  <action>
Create `src/hooks/use-ugeplan.ts`:

```typescript
import useSWR from 'swr'
import useSWRMutation from 'swr/mutation'
import type { Ugeplan, DagNavn } from '@/lib/types'

interface UpdateDagArgs {
  id: string           // Ugeplan record id
  feltNavn: string     // "Mandag", "Tirsdag", etc. (capitalized for Airtable)
  ret: string
  opskriftId?: string
}

interface DeleteDagArgs {
  id: string
  feltNavn: string
}

async function updateDag(
  url: string,
  { arg }: { arg: UpdateDagArgs }
) {
  const res = await fetch('/api/madplan/dag', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ action: 'opdater', ...arg }),
  })
  if (!res.ok) throw new Error('Failed to update day')
  return res.json()
}

async function deleteDag(
  url: string,
  { arg }: { arg: DeleteDagArgs }
) {
  const res = await fetch('/api/madplan/dag', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ action: 'slet', ...arg }),
  })
  if (!res.ok) throw new Error('Failed to delete day')
  return res.json()
}

export function useUgeplan(ejerId: string | null, aar: number, uge: number) {
  const key = ejerId
    ? `/api/madplan/uge?ejerId=${ejerId}&aar=${aar}&uge=${uge}`
    : null

  const { data, error, isLoading, mutate } = useSWR<Ugeplan>(key, {
    keepPreviousData: true,  // Smooth transition when navigating weeks
  })

  const { trigger: triggerUpdate, isMutating: isUpdating } = useSWRMutation(
    key,
    updateDag,
    {
      revalidate: true,  // Refetch after update to get fresh data
    }
  )

  const { trigger: triggerDelete, isMutating: isDeleting } = useSWRMutation(
    key,
    deleteDag,
    {
      revalidate: true,
    }
  )

  // Helper to capitalize day name for Airtable field
  const capitalize = (s: string) => s.charAt(0).toUpperCase() + s.slice(1)

  return {
    ugeplan: data,
    isLoading,
    isError: !!error,
    error,
    mutate,

    // Convenience methods
    updateDay: async (dag: DagNavn, ret: string, opskriftId?: string) => {
      if (!data?.id) throw new Error('No ugeplan loaded')
      return triggerUpdate({
        id: data.id,
        feltNavn: capitalize(dag),
        ret,
        opskriftId,
      })
    },

    deleteDay: async (dag: DagNavn) => {
      if (!data?.id) throw new Error('No ugeplan loaded')
      return triggerDelete({
        id: data.id,
        feltNavn: capitalize(dag),
      })
    },

    isMutating: isUpdating || isDeleting,
  }
}
```
  </action>
  <verify>
Run `npx tsc --noEmit` to verify hook compiles.
Check that updateDay and deleteDay are typed correctly.
  </verify>
  <done>
use-ugeplan.ts created with keepPreviousData, updateDay, and deleteDay methods.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create useIndkobsliste hook with optimistic updates</name>
  <files>madplan-v2/src/hooks/use-indkobsliste.ts</files>
  <action>
Create `src/hooks/use-indkobsliste.ts`:

```typescript
import useSWR from 'swr'
import useSWRMutation from 'swr/mutation'
import type { Indkoebspost } from '@/lib/types'

interface ToggleItemArgs {
  id: string
  afkrydset: boolean
}

interface AddItemArgs {
  ejerId: string
  aar: number
  uge: number
  navn: string
}

async function toggleItem(
  url: string,
  { arg }: { arg: ToggleItemArgs }
) {
  const res = await fetch('/api/madplan/indkob', {
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(arg),
  })
  if (!res.ok) throw new Error('Failed to toggle item')
  return res.json()
}

async function addItem(
  url: string,
  { arg }: { arg: AddItemArgs }
) {
  const res = await fetch('/api/madplan/indkob', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(arg),
  })
  if (!res.ok) throw new Error('Failed to add item')
  return res.json()
}

export function useIndkobsliste(ejerId: string | null, aar: number, uge: number) {
  const key = ejerId
    ? `/api/madplan/indkob?ejerId=${ejerId}&aar=${aar}&uge=${uge}`
    : null

  const { data, error, isLoading, mutate } = useSWR<Indkoebspost[]>(key)

  const { trigger: triggerToggle } = useSWRMutation(key, toggleItem, {
    // Optimistic update: immediately update UI
    optimisticData: (current: Indkoebspost[] | undefined, { arg }) => {
      if (!current) return []
      return current.map((item) =>
        item.id === arg.id ? { ...item, afkrydset: arg.afkrydset } : item
      )
    },
    rollbackOnError: true,    // Revert to previous state on error
    revalidate: false,        // Don't refetch - optimistic update is sufficient
  })

  const { trigger: triggerAdd, isMutating: isAdding } = useSWRMutation(key, addItem, {
    revalidate: true,  // Refetch after add to get new item with ID
  })

  // Group items by category (kilde for now, can be enhanced later)
  // Move checked items to the bottom
  const sortedItems = [...(data ?? [])].sort((a, b) => {
    // Unchecked items first
    if (a.afkrydset !== b.afkrydset) {
      return a.afkrydset ? 1 : -1
    }
    // Then by kilde (ret before manuel)
    if (a.kilde !== b.kilde) {
      return a.kilde === 'ret' ? -1 : 1
    }
    // Then alphabetically
    return a.navn.localeCompare(b.navn, 'da')
  })

  return {
    items: sortedItems,
    isLoading,
    isError: !!error,
    error,
    mutate,

    // Convenience methods
    toggleItem: async (id: string, afkrydset: boolean) => {
      return triggerToggle({ id, afkrydset })
    },

    addItem: async (navn: string) => {
      if (!ejerId) throw new Error('No owner selected')
      return triggerAdd({ ejerId, aar, uge, navn })
    },

    isAdding,
  }
}
```

IMPORTANT: The optimisticData function MUST return the same shape as the current data.
- If current is undefined, return empty array
- Map over current array, don't mutate directly
- Return full array, not just the changed item
  </action>
  <verify>
Run `npx tsc --noEmit` to verify hook compiles.
Check that toggleItem has optimisticData configured.
  </verify>
  <done>
use-indkobsliste.ts created with optimistic checkbox toggle and sorted output.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes
2. All 4 hook files exist in src/hooks/
3. Each hook exports its main function
4. useIndkobsliste has optimisticData in toggle mutation
5. useUgeplan has keepPreviousData for smooth week transitions
</verification>

<success_criteria>
- 4 SWR hooks created: useEjere, useOpskrifter, useUgeplan, useIndkobsliste
- All hooks typed with interfaces from types.ts
- useUgeplan: keepPreviousData enabled, updateDay/deleteDay convenience methods
- useIndkobsliste: optimistic toggle with rollbackOnError, sorted items with checked at bottom
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-data-flow/02-03-SUMMARY.md`
</output>
